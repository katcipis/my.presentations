Responsible Software Development
TODO
22 Jun 2015
Tags: software development, agile, TDD, Refactoring, design, architecture

Tiago Katcipis
tiago.katcipis@neoway.com.br
http://github.com/katcipis


* Agenda

- Who is responsible for the quality of the software ?
- Why TDD ?
- What is TDD ?
- The experience of learning TDD
- TDD Pitfalls
- What about legacy code ?
- When TDD does not matter
- Playing on the feedback space: MDD
- How to start ?


* Who is responsible for the quality of the software ?


* What is quality ?

- Quality is something that depends on scope
- The scope here is functional
- Does the new feature work properly ?
- Any of the previous features broke ?
- We are dividing to conquer :-)


* Should be QA ?


* Manual Testing: The dream

.image ./img/assume-dev-is-propotional-to-test.jpg _ 700


* Manual Testing: Reality

.image ./img/manual-test-is-unsustainable.jpg _ 700


* Manual Testing: Brave fireman

.image ./img/untested-code-gap.jpg _ 700


* Developers are responsible

* Why ?

- Only possible way to scale a system
- The ones that are more involved with the code
- The best way to innovate is by giving freedom
- Freedom without responsibility is just childish
- Matches the approach where a team is responsible for the entire service
- You build it you run it. You build it you test it :-)


* How to handle the responsibility ?


* Ruthless Testing

- Most developers hate testing
- They test gently, subconsciously knowing where the code will break
- Lets face it, testing is hard :-)
- But really pragmatic programmers are driven to find the bugs *now*
- It is easier to catch bugs as soon as they appear
- We want to close this gap as much as we can
- Also have regression for previously tested functionality
- Test Early, Test Often. Test Automatically


* How to test the test ?


* Sabotage !!!

.image ./img/disaster-girl.jpg _ 700


* Messing up with code

- To test the test you have to see it fail
- To make it fail you have to comment out code
- Perhaps, it would be easier to write the test first


* Enters TDD


* The micro cycle

- Write the test first
- Run it, see it fail
- Write the minimum amount of code to make it pass (tricky :-)
- Refactor
- Start again :-)


* Nature of the tests


* FIRST

- Fast
- Isolated
- Repeatable
- Self-verifying
- Timely


* TDD Benefits

* Disclaimer

- TDD is not the only way to achieve any of these objectives
- But if you are having problems with any of these, it *may* help you


* TDD Benefits

- Testability is a first class citizen on your design
- Dependency management problems become explicit on test code
- Enables refactoring
- Executable specification of the system


* Resources / References

- [[https://pragprog.com/magazines/2012-01/unit-tests-are-first][Tests are First]]
- [[http://www.amazon.com/The-Pragmatic-Programmer-Journeyman-Master/dp/020161622X][The Pragmatic Programmer]]
- [[http://www.renaissancesoftware.net/blog/archives/206][Manual Test is Unsustainable]]
- [[https://vimeo.com/68375232][Ian Cooper: TDD, where did it all go wrong]]
- [[http://www.se-radio.net/2010/09/episode-167-the-history-of-junit-and-the-future-of-testing-with-kent-beck/][The History of JUnit and the Future of Testing with Kent Beck]]
